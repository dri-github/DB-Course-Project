------------------------------------------
-- System error codes:
--  * -20001 - internal error
--  * -20002 - field(-s) has value null
--  * -20003 - incorrectly entered data
--  * -20004 - incorrect value
--  * -20005 - does not exist
--  * -20006 - already exist
--  * ...
--  * -20021 - not allowed
--  * -20022 - there are empty fields
--  * -20023 - invalide user or password
--  * -20024 - not privilegies
--  * -20025 - invalide invoice or invoice owner
--  * -20026 - invalide auto_transfer or auto transfer owner
--  * -20027 - invoice exist child
--  * -20028 - invalide card or card owner
--  * -20029 - invalid user type
--  * -20030 - worker is not invited
------------------------------------------

create tablespace ts_data
    datafile 'TS_BANK_DATA.dbf'
    size 40m
    autoextend on next 2m
    extent management local;

create tablespace ts_log
    datafile 'TS_BANK_LOG.dbf'
    size 20m
    autoextend on next 4m
    extent management local;

create profile pf_terminal limit
    password_life_time unlimited
    sessions_per_user 20
    failed_login_attempts 7
    password_reuse_time 10
    password_grace_time default
    connect_time 180
    idle_time 30;

create profile pf_local_admin limit
    password_life_time 180
    sessions_per_user 10
    failed_login_attempts 7
    password_reuse_time 10
    password_grace_time default
    connect_time 180
    idle_time 30;

create user bank_user identified by "user" account unlock;
create user bank_employee identified by "employee" account unlock;
create user terminal identified by "pass" profile pf_terminal account unlock;
create user local_admin identified by "admin" profile pf_local_admin account unlock;

------------------------------------------
-- Contains all subjects that can interact with the system
--   Users are identified by passport id and user type.
--   Users with different types and same passport id will be one user (conditionally).
--   This allows accountant to have a jobe and a home account.
--
-- Users separate by type:
--  * base - a user who can create an account, log in to it, create invoices, add auto transfers, read messages
--  * accountant - this user cannot create this account, but can log in to it, create invoices, send messages, register workers
--  * organization - the user will be a legal or natural person of organization, can create an accountant account
--  * terminal - user allocated for bank terminals and other devices
--
-- Statuses:
--  * lock - the user cannot log into the account
--  * unlock - default state
------------------------------------------
create table users(
    passport_id     char(14),
    type            varchar2(14)    not null,
    surname         varchar2(32),
    given_name      varchar2(60),
    passport_number char(9)         not null,
    telephone       number(12),
    email           varchar2(40),
    address         varchar2(60),
    status          varchar2(6)     default 'unlock' not null,
    password        varchar2(32)    not null,
    
    constraint users_pk_user_id   primary key(passport_id, type),
    constraint users_chk_type     check(type in ('base', 'accountant', 'organization', 'terminal', 'bank employee')),
    constraint users_chk_status   check(status in ('unlock', 'lock'))
) tablespace ts_data;

insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
    values ('00000000000000', 'organization', 'UBS', 'Universal Bank System', '000000000', '375000000000', 'universal_bank_system@gmail.com', 'Minsk, Sverdlova 13', 'unlock', 'bank');

------------------------------------------
-- Contains currency with value on current time
------------------------------------------
create table currency(
    short_name  varchar2(10) primary key,
    name        varchar2(40) not null,
    value       float        not null
) tablespace ts_data;

------------------------------------------
-- Contains all updates values of currency
------------------------------------------
create table currency_log(
    id          number          generated by default as identity primary key,
    short_name  varchar2(10),
    date_time   date,
    delta       float
) tablespace ts_log;

create trigger currency_update after update on currency for each row
begin
    insert into currency_log(short_name, date_time, delta)
        values (:new.short_name, sysdate, :new.value - :old.value);
end;

------------------------------------------
-- Contains users invoices with invoices type, value and currency
--
-- Invoices types:
--  * root - main invoice, does not have a parent invoice but can child invoices
--  * clone - repeats all events with the parent invoice
--
-- Invoices statuses:
--  * lock - no one can interact with the invoice except bank employee
--  * unlock - default invoice status to use
------------------------------------------
create table invoices(
    id          number(24)      primary key,
    user_id     char(14),
    user_type   varchar2(14),
    value       number(28, 2)   check(value >= 0) not null,
    currency    varchar2(10)    references currency(short_name) not null,
    type        varchar2(10)    not null,
    status      varchar2(6)     default 'unlock' not null,
    root        number(24)      references invoices(id) null,
    
    constraint invoices_fk_invoice_user  foreign key (user_id, user_type) references users(passport_id, type),
    constraint invoices_chk_type         check(type in ('root', 'clone')),
    constraint invoices_chk_status       check(status in ('unlock', 'lock'))
) tablespace ts_data;
create sequence invoices_ids minvalue 0 start with 0 increment by 1 cache 4 order;

------------------------------------------
-- Contains translations that must be performed automatically at a certain frequency
--
-- Autotransfers types:
--  * credit - transfers funds to the account of the sender of the transfer and obliges
--    the sender to pay the recipient a portion of the amount with interest every mounth
--  * contribution - like a loan but on the part of the user who gave the funds for a while
--  * salary - used the system to pay funds to employees when working for the organization
--
-- Autotransfers statuses:
--  * active - default status
--  * suspended - the transfer of funds has been stopped, the funds have not been paid in
--    full, the transition to this state is carried out by the user
--  * completed - the transfer of funds has been stopped, the funds have been paid in
--    full, the transition to this state is carried out by the system
------------------------------------------
create table auto_transfers(
    id              number          primary key,
    from_invoice    number(24)      references invoices(id),
    to_invoice      number(24)      references invoices(id),
    value           number(28, 2)   check(value > 0) not null,
    percent         float           check(percent >= 0 and percent <= 1) not null,
    type            varchar2(14)    not null,
    open_date       date            not null,
    duration        number(3)       null,
    status          varchar2(10)    not null,
    
    constraint auto_transfers_chk_type     check(type in ('credit', 'contribution', 'salary')),
    constraint auto_transfers_chk_status   check(status in ('active', 'suspended', 'completed'))
) tablespace ts_data;
create sequence auto_transfers_ids minvalue 0 start with 0 increment by 1 cache 4 order;

------------------------------------------
-- Contains connections between users and the place of work where they work.
--   Communication with the user is carried out by creating a record of the automatic
--   transfer of funds to the specified user account.
--   The employee registration table for work saves the identifier ot the automatic transfer of funds.
--
-- Register types:
--  * invited - the employee was invited to work and has not yet accepted the invitation
--  * accepted - the employee accepted the job offer and receives a salary
--  * quit - the employee quit or was fired
------------------------------------------
create table workers_register(
    id number generated by default as identity primary key,
    organization_id    char(14)     not null,
    organization_type  varchar2(14) not null,
    worker_id          char(14)     not null,
    worker_type        varchar2(14) not null,
    job_title          varchar2(30) not null,
    transfer_id        number       references auto_transfers(id),
    date_time          date         not null,
    status             varchar2(10) not null,
    
    constraint workers_register_organization    foreign key(organization_id, organization_type) references users(passport_id, type),
    constraint workers_register_worker          foreign key(worker_id, worker_type) references users(passport_id, type),
    constraint workers_register_chk_status      check(status in ('invited', 'accepted', 'quit'))
) tablespace ts_data;

------------------------------------------
-- Messages are used to notify users of system events or messages from higher-level users
--
-- Message types:
--  * notification - informs the user about some event or change
--  * confirmation - sent upon an event for which mandatory comfirmation user is required
--  * error - exclusively a system message notifying about an error in user actions
------------------------------------------
create table messages(
    id          number          generated by default as identity primary key,
    user_id     char(14),
    user_type   varchar2(14),
    text        varchar2(300)   not null,
    type        varchar2(12)    not null,
    date_time   date            not null,
    
    constraint messages_fk_user      foreign key(user_id, user_type) references users(passport_id, type),
    constraint messages_chk_type     check(type in ('notification', 'confirmation', 'error'))
) tablespace ts_data;

------------------------------------------
-- Containts data of physical cards of all users
--
-- Card status:
--  * look - prohibits operations on the card
--  * unlook - default state
------------------------------------------
create table cards(
    id        number(16)    primary key,
    invoice   number(24)    references invoices(id),
    pincode   number(4)     not null,
    status    varchar2(6)   not null,
    
    constraint cards_chk_status check(status in ('lock', 'unlock'))
) tablespace ts_data;
create sequence cards_ids minvalue 0 start with 0 increment by 1 cache 4 order;

create table transfers_log(
    id              number          generated by default as identity primary key,
    from_invoice    number(24)      references invoices(id),
    to_invoice      number(24)      references invoices(id),
    value           number(28, 2)   check(value > 0) not null,
    date_time       date            not null,
    type            varchar2(10)    not null,
    status          varchar2(14)    not null,
    
    constraint transfers_log_chk_type   check(type in ('simple', 'credit', 'contribution')),
    constraint transfers_log_chk_status check(status in ('success', 'error'))
) tablespace ts_log;

create table changes_log(
    id          number          generated by default as identity primary key,
    type        varchar2(8)     not null,
    event_name  varchar2(60)    not null,
    description varchar2(320)    not null,
    date_time   date            not null,
    
    constraint changes_log_chk_type check(type in ('insert', 'update', 'delete', 'special', 'error'))
) tablespace ts_log;
create index idx_changes_log_date on changes_log(date_time);

create table internal_errors_log(
    id          number        generated by default as identity primary key,
    sqlerrcode  number        not null,
    message     varchar2(320) not null,
    event_name  varchar2(60)  not null,
    parameters  varchar2(400) not null,
    date_time   date          not null
) tablespace ts_log;

------------------------------------------
-- Create triggers
------------------------------------------

create or replace trigger users_changes after insert or update or delete on users for each row
begin
    if inserting then
        insert into changes_log(type, event_name, description, date_time)
            values ('insert', 'users changes', :new.passport_id || '?' || :new.type || '?' || :new.surname || '?' || :new.given_name || '?' || :new.passport_number || '?' || :new.telephone || '?' || :new.email || '?' || :new.address || '?' || :new.status, sysdate);
    elsif updating then
        insert into changes_log(type, event_name, description, date_time)
            values ('update', 'users changes', :new.passport_id || '?' || :new.type || '?' || :new.surname || '?' || :new.given_name || '?' || :new.passport_number || '?' || :new.telephone || '?' || :new.email || '?' || :new.address || '?' || :new.status, sysdate);
    elsif deleting then
        insert into changes_log(type, event_name, description, date_time)
            values ('delete', 'users changes', :old.passport_id || '?' || :old.type || '?' || :old.surname || '?' || :old.given_name || '?' || :old.passport_number || '?' || :old.telephone || '?' || :old.email || '?' || :old.address || '?' || :old.status, sysdate);
    end if;
end;

create or replace trigger invoices_changes after insert or update or delete on invoices for each row
begin
    if inserting then
        insert into changes_log(type, event_name, description, date_time)
            values ('insert', 'invoices changes', :new.id || '?' || :new.user_id || '?' || :new.user_type || '?' || :new.value || '?' || :new.currency || '?' || :new.type || '?' || :new.status || '?' || :new.root, sysdate);
    elsif updating then
        insert into changes_log(type, event_name, description, date_time)
            values ('update', 'invoices changes', :new.id || '?' || :new.user_id || '?' || :new.user_type || '?' || :new.value || '?' || :new.currency || '?' || :new.type || '?' || :new.status || '?' || :new.root, sysdate);
    elsif deleting then
        insert into changes_log(type, event_name, description, date_time)
            values ('delete', 'invoices changes', :old.id || '?' || :old.user_id || '?' || :old.user_type || '?' || :old.value || '?' || :old.currency || '?' || :old.type || '?' || :old.status || '?' || :old.root, sysdate);
    end if;
end;

create or replace trigger cards_changes after insert or update or delete on cards for each row
begin
    if inserting then
        insert into changes_log(type, event_name, description, date_time)
            values ('insert', 'cards changes', :new.id || '?' || :new.invoice || '?' || :new.currency || '?' || :new.pincode || '?' || :new.status, sysdate);
    elsif updating then
        insert into changes_log(type, event_name, description, date_time)
            values ('update', 'cards changes', :new.id || '?' || :new.invoice || '?' || :new.currency || '?' || :new.pincode || '?' || :new.status, sysdate);
    elsif deleting then
        insert into changes_log(type, event_name, description, date_time)
            values ('delete', 'cards changes', :old.id || '?' || :old.invoice || '?' || :old.currency || '?' || :old.pincode || '?' || :old.status, sysdate);
    end if;
end;

create or replace trigger workers_register_changes after insert or update or delete on workers_register for each row
begin
    if inserting then
        insert into changes_log(type, event_name, description, date_time)
            values ('insert', 'workers register changes', :new.organization_id || '?' || :new.worker_id || '?' || :new.job_title || '?' || :new.transfer_id || '?' || :new.date_time || '?' || :new.status, sysdate);
    elsif updating then
        insert into changes_log(type, event_name, description, date_time)
            values ('update', 'workers register changes', :new.organization_id || '?' || :new.worker_id || '?' || :new.job_title || '?' || :new.transfer_id || '?' || :new.date_time || '?' || :new.status, sysdate);
    elsif deleting then
        insert into changes_log(type, event_name, description, date_time)
            values ('delete', 'workers register changes', :old.organization_id || '?' || :old.worker_id || '?' || :old.job_title || '?' || :old.transfer_id || '?' || :old.date_time || '?' || :old.status, sysdate);
    end if;
end;

create or replace trigger auto_transfers_changes after insert or update or delete on auto_transfers for each row
begin
    if inserting then
        insert into changes_log(type, event_name, description, date_time)
            values ('insert', 'auto transfers changes', :new.id || '?' || :new.from_invoice || '?' || :new.to_invoice || '?' || :new.value || '?' || :new.percent || '?' || :new.type || '?' || :new.open_date || '?' || :new.duration || '?' || :new.status, sysdate);
    elsif updating then
        insert into changes_log(type, event_name, description, date_time)
            values ('update', 'auto transfers changes', :new.id || '?' || :new.from_invoice || '?' || :new.to_invoice || '?' || :new.value || '?' || :new.percent || '?' || :new.type || '?' || :new.open_date || '?' || :new.duration || '?' || :new.status, sysdate);
    elsif deleting then
        insert into changes_log(type, event_name, description, date_time)
            values ('delete', 'auto transfers changes', :old.id || '?' || :old.from_invoice || '?' || :old.to_invoice || '?' || :old.value || '?' || :old.percent || '?' || :old.type || '?' || :old.open_date || '?' || :old.duration || '?' || :old.status, sysdate);
    end if;
end;

------------------------------------------
-- Create functions
------------------------------------------

create or replace function is_type(
    p_passport_id  in root_admin.users.passport_id%type,
    p_type         in root_admin.users.type%type
) return boolean
is
    m_users_count integer := 0;
begin
    select count(*) into m_users_count from users where passport_id = p_passport_id and type = p_type;
    return m_users_count > 0;
end;

create or replace function is_verified_user(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type
) return boolean
is
    users_count integer := 0;
begin
    select count(*) into users_count from users where passport_id = p_passport_id and type = p_user_type and password = p_password and status = 'unlock';
    return users_count > 0;
end;

create or replace function is_have_child(
    p_invoice_id in root_admin.invoices.id%type
) return boolean
is
    child_count int;
begin
    select count(*) into child_count from invoices where root = p_invoice_id;
    return child_count > 0;
end;

create or replace function is_invoice_owner(
    p_passport_id in root_admin.users.passport_id%type,
    p_user_type   in root_admin.users.type%type,
    p_invoice_id  in root_admin.invoices.id%type
) return boolean
is
    m_invoices_row root_admin.invoices%rowtype;
begin
    select id, user_id, user_type, value, currency, type, status, root into m_invoices_row from invoices where id = p_invoice_id;
    if m_invoices_row.user_id = p_passport_id and m_invoices_row.user_type = p_user_type then
        return true;
    end if;
    if m_invoices_row.root is not null then
        return is_invoice_owner(p_passport_id, p_user_type, m_invoices_row.root);
    end if;
    
    return false;
end;

create or replace function is_exist_invoice(
    p_invoice_id in root_admin.invoices.id%type
) return boolean
is
    invoices_count integer;
begin
    select count(*) into invoices_count from invoices where id = p_invoice_id;
    return invoices_count > 0;
end;

create or replace function is_auto_transfer_owner(
    p_passport_id       in root_admin.users.passport_id%type,
    p_user_type         in root_admin.users.type%type,
    p_auto_transfer_id  in root_admin.auto_transfers.id%type
) return boolean
is
    auto_transfers_count integer := 0;
begin
    select count(*) into auto_transfers_count
    from auto_transfers atr
        join invoices inv on atr.from_invoice = inv.id
    where atr.id = p_auto_transfer_id and inv.user_id = p_passport_id and inv.user_type = p_user_type;
    return auto_transfers_count > 0;
end;

create or replace function is_card_owner(
    p_passport_id  in root_admin.users.passport_id%type,
    p_card_id      in root_admin.cards.id%type
) return boolean
is
    cards_count integer;
begin
    select count(*) into cards_count
    from cards crd
        join invoices inv on crd.invoice = inv.id
    where crd.id = p_card_id and inv.user_id = p_passport_id;
    return cards_count > 0;
end;

create or replace function get_currency_value(
    p_currency in root_admin.currency.short_name%type
) return root_admin.currency.value%type
is
    currency_value root_admin.currency.value%type := 0;
begin
    select value into currency_value from currency where short_name = p_currency;
    return currency_value;
end;

create type t_jobs_row as object(
    organization_name  varchar2(40),
    job_title          varchar2(20),
    experience         integer,
    register_date      date,
    salary             integer,
    bind_invoice       number(24),
    status             varchar2(10)
);
create type t_jobs as table of t_jobs_row;
create or replace function get_user_jobs(
    p_passport_id  in root_admin.users.passport_id%type,
    p_password     in root_admin.users.password%type
) return t_jobs
is
    t_result t_jobs := t_jobs();
begin
    select t_jobs_row(o.surname, w.job_title, months_between(sysdate, w.date_time), w.date_time, t.value, t.to_invoice, w.status)
    bulk collect into t_result
    from workers_register w
        join auto_transfers t on t.id = w.transfer_id
        join users o          on o.passport_id = w.organization_id
    where w.worker_id = p_passport_id and o.password = p_password;
    
    return t_result;
end;

create type t_invoices_row as object(
    id          number(24),
    value       integer,
    currency    varchar2(10),
    type        varchar2(10),
    owner_id    char(14),
    owner_type  varchar2(14),
    status      varchar2(6),
    root        number(24)
);
create type t_invoices as table of t_invoices_row;
create or replace function get_child_invoices(
    p_current_invoice in root_admin.invoices.id%type
) return t_invoices
is
    cursor curs_childs(current_invoice root_admin.invoices.id%type) is select id, user_id, user_type, value, currency, type, status, root from invoices where root = current_invoice;

    t_result t_invoices := t_invoices();
begin
    for child_invoice in curs_childs(p_current_invoice) loop
        t_result := t_result multiset union all get_child_invoices(child_invoice.id);
        t_result.extend;
        t_result(t_result.count) := t_invoices_row(child_invoice.id, child_invoice.value, child_invoice.currency, child_invoice.type, child_invoice.user_id, child_invoice.user_type, child_invoice.status, child_invoice.root);
    end loop;
    
    return t_result;
end;

create or replace function get_user_invoices(
    passport_id  in root_admin.users.passport_id%type,
    user_type    in root_admin.users.type%type,
    password     in root_admin.users.password%type
) return t_invoices
is
    cursor curs_childs(
        p_passport_id in root_admin.users.passport_id%type,
        p_user_type   in root_admin.users.type%type
    ) is select id, user_id, user_type, value, currency, type, status, root from invoices where user_id = p_passport_id and user_type = p_user_type;

    t_result t_invoices := t_invoices();
begin
    if is_verified_user(passport_id, user_type, password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get user invoices', 'Invalide user or password "' || passport_id || '?' || user_type || '"', sysdate);
        raise_application_error(-20023, 'Invalide user or password');
        return t_result;
    end if;

    for child_invoice in curs_childs(passport_id, user_type) loop
        t_result := t_result multiset union all get_child_invoices(child_invoice.id);
        t_result.extend;
        t_result(t_result.count) := t_invoices_row(child_invoice.id, child_invoice.value, child_invoice.currency, child_invoice.type, child_invoice.user_id, child_invoice.user_type, child_invoice.status, child_invoice.root);
    end loop;
    
    return t_result;
end;

create type t_users_row as object(
    surname         varchar2(16),
    given_name      varchar2(16),
    passport_number char(9),
    telephone       number(12),
    email           varchar2(30),
    address         varchar2(60)
);
create type t_users as table of t_users_row;
create or replace function get_personal_data(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type
) return t_users
is
    t_result t_users := t_users();
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get personal data', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '"', sysdate);
        raise_application_error(-20023, 'Invalide user or password');
        return t_result;
    end if;
    
    select t_users_row(surname, given_name, passport_number, telephone, email, address) bulk collect into t_result
        from users where passport_id = p_passport_id and type = p_user_type and password = p_password;
    return t_result;
end;

create type t_messages_row as object(
    description varchar2(300),
    type        varchar2(12),
    date_time   date
);
create type t_messages as table of t_messages_row;
create function get_user_messages(
    passport_id  in root_admin.users.passport_id%type,
    user_type    in root_admin.users.type%type,
    password     in root_admin.users.password%type
) return t_messages
is
    t_result t_messages := t_messages();
begin
    if is_verified_user(passport_id, user_type, password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get user messages', 'Invalide user or password "' || passport_id || '?' || user_type || '"', sysdate);
        raise_application_error(-20023, 'Invalide user or password');
        return t_result;
    end if;

    select t_messages_row(text, type, date_time)
    bulk collect into t_result
    from messages
    where user_id = passport_id and user_type = user_type;
    
    return t_result;
end;

create type t_cards_row as object(
    id        number(16),
    invoice   number(24),
    currency  varchar2(10),
    value     number(28, 2),
    status    varchar2(6)
);
create type t_cards as table of t_cards_row;
create function get_user_cards(
    passport_id  in root_admin.users.passport_id%type,
    user_type    in root_admin.users.type%type,
    password     in root_admin.users.password%type
) return t_cards
is
    t_result t_cards := t_cards();
begin
    if is_verified_user(passport_id, user_type, password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get user cards', 'Invalide user or password "' || passport_id || '?' || user_type || '"', sysdate);
        raise_application_error(-20023, 'Invalide user or password');
        return t_result;
    end if;

    select t_cards_row(c.id, c.invoice, c.currency, i.value, c.status)
    bulk collect into t_result
    from cards c
        join invoices i on c.invoice = i.id
    where i.user_id = passport_id and i.user_type = user_type;
    
    return t_result;
end;

create type t_workers_row as object(
    bind_invoice       number(24),
    worker_invoice     number(24),
    surname            varchar2(16),
    given_name         varchar2(16),
    telephone          number(12),
    address            varchar2(60),
    email              varchar2(30),
    job_title          varchar2(20),
    salary             float,
    registration_date  date
);
create type t_workers as table of t_workers_row;
create or replace function get_workers(
    p_passport_id  in root_admin.users.passport_id%type,
    p_password     in root_admin.users.password%type,
    p_invoice      in root_admin.invoices.id%type
) return t_workers
is
    t_result t_workers := t_workers();
begin
    if is_verified_user(p_passport_id, 'accountant', p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get_workers', 'Invalide user or password "' || p_passport_id || '?' || p_invoice || '"', sysdate);
        commit;
        raise_application_error(-20023, 'Invalide user or password');
        return t_result;
    end if;
    
    if is_invoice_owner(p_passport_id, 'accountant', p_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'get_workers', 'The specified invoice does not exist for the user "' || p_passport_id || '?' || p_invoice || '"', sysdate);
        commit;
        raise_application_error(-20005, 'The specified invoice does not exist for the user');
    end if;
    
    select t_workers_row(atr.from_invoice, atr.to_invoice, usr.surname, usr.given_name, usr.telephone, usr.address, usr.email, wrg.job_title, atr.value, atr.open_date)
    bulk collect into t_result 
    from auto_transfers atr
        join workers_register wrg on atr.id = wrg.transfer_id
        join invoices inv on atr.to_invoice = inv.id
        join users usr on inv.user_id = usr.passport_id and inv.user_type = usr.type
    where wrg.status = 'accepted' and atr.from_invoice = p_invoice;
    
    return t_result;
end;

create or replace function get_organization_by_invoice(
    p_invoice in root_admin.invoices.id%type
) return root_admin.invoices.user_id%type
is
    m_invoice_row root_admin.invoices%rowtype;
begin
    select id, user_id, user_type, value, currency, type, status, root into m_invoice_row from invoices where id = p_invoice;
    if m_invoice_row.user_type = 'organization' then
        return m_invoice_row.user_id;
    end if;
    if m_invoice_row.root is null then
        return m_invoice_row.user_id; --may be need null
    end if;
    
    return get_organization_by_invoice(m_invoice_row.root);
end;

create or replace function get_invoice_value(
    p_invoice in root_admin.invoices.id%type
) return float
is
    m_value root_admin.invoices.value%type;
    m_currency root_admin.invoices.currency%type;
begin
    select value, currency into m_value, m_currency from invoices where id = p_invoice;
    return m_value / get_currency_value(m_currency);
end;

------------------------------------------
-- Create procedures
------------------------------------------

create or replace procedure log_internal_error(
    p_event_name  in root_admin.internal_errors_log.event_name%type,
    p_text        in root_admin.internal_errors_log.parameters%type
)
as
    errcode number := sqlcode;
    errmsg varchar2(320) := sqlerrm;
begin
    rollback;
    insert into internal_errors_log(sqlerrcode, message, event_name, parameters, date_time)
        values (errcode, errmsg, p_event_name, p_text, sysdate);
    commit;
    raise_application_error(-20001, 'Internal error');
end;

create or replace procedure apply_for_job(
    p_organization_id       in root_admin.users.passport_id%type,
    p_worker_id             in root_admin.users.passport_id%type,
    p_worker_invoice        in root_admin.invoices.id%type,
    p_organization_invoice  in root_admin.invoices.id%type := null,
    p_job_title             in root_admin.workers_register.job_title%type := 'worker',
    p_salary                in root_admin.auto_transfers.value%type := 0
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);

    m_transfer_id number := null;
begin
    if p_organization_invoice is null then
        update workers_register set status = 'accepted' where organization_id = p_organization_id and worker_id = p_worker_id and status = 'invited' returning transfer_id into m_transfer_id;
        if sql%rowcount = 0 then
            raise no_data_found;
        end if;
        update auto_transfers set to_invoice = p_worker_invoice, status = 'active', open_date = sysdate where id = m_transfer_id;
    else
        m_transfer_id := auto_transfers_ids.nextval;
        if p_worker_invoice is null then
            insert into auto_transfers(id, from_invoice, to_invoice, value, percent, type, open_date, duration, status)
                values (m_transfer_id, p_organization_invoice, null, p_salary, 0, 'salary', sysdate, null, 'suspended');
    
            insert into workers_register(organization_id, organization_type, worker_id, worker_type, job_title, transfer_id, date_time, status)
                values (p_organization_id, 'organization', p_worker_id, 'base', p_job_title, m_transfer_id, sysdate, 'invited');
        else
            insert into auto_transfers(id, from_invoice, to_invoice, value, percent, type, open_date, duration, status)
                values (m_transfer_id, p_organization_invoice, p_worker_invoice, p_salary, 0, 'salary', sysdate, null, 'active');
    
            insert into workers_register(organization_id, organization_type, worker_id, worker_type, job_title, transfer_id, date_time, status)
                values (p_organization_id, 'organization', p_worker_id, 'base', p_job_title, m_transfer_id, sysdate, 'accepted');
        end if;
    end if;
    
exception
    when no_data_found then
    begin
        raise_application_error(-20030, 'The worker is not invited to this organization');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when others then
    begin
        log_internal_error('apply for job', p_organization_id || '?' || p_worker_id || '?' || p_worker_invoice);
    end;
end;

create sequence terminal_ids minvalue 0 start with 0 increment by 1 order;
create or replace procedure register_terminal(
    p_manufacturer     in root_admin.users.surname%type,
    p_model            in root_admin.users.given_name%type,
    p_address          in root_admin.users.address%type,
    p_terminal_number  in root_admin.users.passport_number%type,
    p_password         in root_admin.users.password%type,
    p_terminal_id      out root_admin.users.passport_id%type
)
is begin--
    p_terminal_id := terminal_ids.nextval;
    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        values (p_terminal_id, 'terminal', p_manufacturer, p_model, p_terminal_number, null, null, p_address, 'unlock', p_password);
    
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register terminal', 'The terminal already exists ' || p_manufacturer || '?' || p_model || '?' || p_address || '?' || p_terminal_number || '?' || p_terminal_id, sysdate);
        raise_application_error(-20006, 'The terminal already exists');
    end;
    when others then
    begin
        log_internal_error('register terminal', p_manufacturer || '?' || p_model || '?' || p_address || '?' || p_terminal_number || '?' || p_terminal_id);
    end;
end;

create or replace procedure register_user(
    p_passport_id     in root_admin.users.passport_id%type,
    p_surname         in root_admin.users.surname%type,
    p_given_name      in root_admin.users.given_name%type,
    p_passport_number in root_admin.users.passport_number%type,
    p_telephone       in root_admin.users.telephone%type,
    p_email           in root_admin.users.email%type,
    p_address         in root_admin.users.address%type,
    p_password        in root_admin.users.password%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    empty_field exception;
    pragma exception_init(empty_field, -20022);
begin
    if length(p_passport_id) < 14 then
        raise_application_error(-20022, 'Passport id is not full');
    end if;
    
    if p_surname is null then
        raise_application_error(-20022, 'Surname field is empty');
    elsif p_given_name is null then
        raise_application_error(-20022, 'Given name field is empty');
    elsif p_address is null then
        raise_application_error(-20022, 'Address field is empty');
    elsif p_telephone is null or p_telephone < 1000000000 then
        raise_application_error(-20022, 'Telephone field is incorrect');
    end if;

    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        values (p_passport_id, 'base', p_surname, p_given_name, p_passport_number, p_telephone, p_email, p_address, 'unlock', p_password);
    
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register user', 'The user "' || p_passport_id || '?' || p_surname || '?' || p_given_name || '?' || p_passport_number || '?' || p_telephone || '?' || p_email || '?' || p_address  || '" already exists', sysdate);
        raise_application_error(-20006, 'The user already exists');
    end;
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when empty_field then
        raise;
    when others then
    begin
        log_internal_error('register user', p_passport_id || '?' || p_surname || '?' || p_given_name || '?' || p_passport_number || '?' || p_telephone || '?' || p_email || '?' || p_address);
    end;
end;

create or replace procedure register_worker(
    p_organization_id       in root_admin.users.passport_id%type,
    p_organization_invoice  in root_admin.invoices.id%type,
    p_worker_id             in root_admin.users.passport_id%type,
    p_job_title             in root_admin.workers_register.job_title%type,
    p_salary                in root_admin.invoices.value%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    worker_only exception;
    pragma exception_init(worker_only, -20029);
begin
    if is_type(p_organization_id, 'organization') = false then
        raise_application_error(-20029, 'You can register worker only to organization');
    end if;
    
    apply_for_job(p_organization_id, p_worker_id, null, p_organization_invoice, p_job_title, p_salary);
    
    insert into messages(user_id, user_type, text, type, date_time)
        values (p_worker_id, 'base', 'If you job in organization ' || p_organization_id || ' apply this message', 'confirmation', sysdate);
    
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register worker', 'The worker is already exists in this organization ' || p_organization_id || '?' || p_organization_invoice || '?' || p_worker_id || '?' || p_salary, sysdate);
        commit;
        raise_application_error(-20006, 'The worker is already exists in this organization');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when no_data_found then
        raise;
    when worker_only then
        raise;
    when others then
    begin
        log_internal_error('register worker', p_organization_id || '?' || p_organization_invoice || '?' || p_worker_id || '?' || p_salary);
    end;
end;

create or replace procedure register_bank_employee(
    p_owner_id        in root_admin.users.passport_id%type,
    p_owner_type      in root_admin.users.type%type,
    p_owner_password  in root_admin.users.password%type,
    p_passport_id     in root_admin.users.passport_id%type,
    p_telephone       in root_admin.users.telephone%type,
    p_email           in root_admin.users.email%type,
    p_address         in root_admin.users.address%type,
    p_user_invoice    in root_admin.invoices.id%type,
    p_password        in root_admin.users.password%type,
    p_bind_invoice    in root_admin.invoices.id%type,
    p_job_title       in root_admin.workers_register.job_title%type,
    p_salary          in root_admin.auto_transfers.value%type
)
is
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    
    m_base_users_row root_admin.users%rowtype;
begin
    if length(p_passport_id) < 14 then
        raise_application_error(-20022, 'Passport id is not full');
    end if;
    
    if p_owner_type not in ('accountant', 'organization') then
        raise_application_error(-20029, 'Invalid user type');
    end if;

    if is_verified_user(p_owner_id, p_owner_type, p_owner_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register bank employee', 'Invalide organization or password "' || p_owner_id || '?' || p_owner_type || '?' || p_owner_password || '?' || p_passport_id || '?' || p_bind_invoice || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_invoice_owner(p_owner_id, p_owner_type, p_bind_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register bank employee', 'The organization not belongs this invoice ' || p_owner_id || '?' || p_owner_type || '?' || p_owner_password || '?' || p_passport_id || '?' || p_bind_invoice, sysdate);
        raise_application_error(-20025, 'Invalid invoice or organization owner invoice');
    end if;

    if is_type(p_passport_id, 'base') = false then
        raise_application_error(-20005, 'No base account exists');
    end if;
    
    select passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password into m_base_users_row from users where passport_id = p_passport_id and type = 'base';
    
    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        values (p_passport_id, 'bank employee', m_base_users_row.surname, m_base_users_row.given_name, m_base_users_row.passport_number, p_telephone, p_email, p_address, 'unlock', p_password);
        
    apply_for_job(get_organization_by_invoice(p_bind_invoice), p_passport_id, p_user_invoice, p_bind_invoice, p_job_title, p_salary);
    
exception
     when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when null_constraint then
        raise;
    when no_data_found then
        raise;
    when others then
    begin
        log_internal_error('register bank employee', p_passport_id);
    end;
end;

create or replace procedure register_accountant(
    p_owner_id        in root_admin.users.passport_id%type,
    p_owner_type      in root_admin.users.type%type,
    p_owner_password  in root_admin.users.password%type,
    p_passport_id     in root_admin.users.passport_id%type,
    p_telephone       in root_admin.users.telephone%type,
    p_email           in root_admin.users.email%type,
    p_address         in root_admin.users.address%type,
    p_user_invoice    in root_admin.invoices.id%type,
    p_password        in root_admin.users.password%type,
    p_bind_invoice    in root_admin.invoices.id%type,
    p_job_title       in root_admin.workers_register.job_title%type,
    p_salary          in root_admin.auto_transfers.value%type
)
is
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);

    m_base_users_row root_admin.users%rowtype;
begin
    if p_owner_type not in ('accountant', 'organization') then
        raise_application_error(-20029, 'Invalid user type');
    end if;

    if is_verified_user(p_owner_id, p_owner_type, p_owner_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register accountant', 'Invalide organization or password "' || p_owner_id || '?' || p_owner_type || '?' || p_owner_password || '?' || p_passport_id || '?' || p_bind_invoice || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_invoice_owner(p_owner_id, p_owner_type, p_bind_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register accountant', 'The organization not belongs this invoice ' || p_owner_id || '?' || p_owner_type || '?' || p_owner_password || '?' || p_passport_id || '?' || p_bind_invoice, sysdate);
        raise_application_error(-20025, 'Invalid invoice or organization owner invoice');
    end if;

    if is_type(p_passport_id, 'base') = false then
        raise_application_error(-20005, 'No base account exists');
    end if;
    
    select passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password into m_base_users_row from users where passport_id = p_passport_id and type = 'base';
    
    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        values (p_passport_id, 'accountant', m_base_users_row.surname, m_base_users_row.given_name, m_base_users_row.passport_number, p_telephone, p_email, p_address, 'unlock', p_password);
        
    apply_for_job(get_organization_by_invoice(p_bind_invoice), p_passport_id, p_user_invoice, p_bind_invoice, p_job_title, p_salary);
    update invoices set user_id = p_passport_id, user_type = 'accountant' where id = p_bind_invoice;
    
exception
    when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when null_constraint then
        raise;
    when no_data_found then
        raise;
    when others then
    begin
        log_internal_error('register accountant', p_owner_id || '?' || p_owner_type || '?' || p_owner_password || '?' || p_passport_id || '?' || p_bind_invoice);
    end;
end;

create or replace procedure register_organization(
    p_editor_id       in root_admin.users.passport_id%type,
    p_editor_password in root_admin.users.password%type,
    p_passport_id     in root_admin.users.passport_id%type,
    p_surname         in root_admin.users.surname%type,
    p_given_name      in root_admin.users.given_name%type,
    p_passport_number in root_admin.users.passport_number%type,
    p_telephone       in root_admin.users.telephone%type,
    p_email           in root_admin.users.email%type,
    p_address         in root_admin.users.address%type,
    p_password        in root_admin.users.password%type
)
is
    invalid_editor exception;
    pragma exception_init(invalid_editor, -20023);
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    empty_field exception;
    pragma exception_init(empty_field, -20022);
begin
    if is_verified_user(p_editor_id, 'bank employee', p_editor_password) = false then
        raise_application_error(-20023, 'Invalid editor user or password');
    end if;
    
    if is_type(p_passport_id, 'base') = false then
        raise_application_error(-20005, 'No base account exists');
    end if;
    
    if p_surname is null then
        raise_application_error(-20022, 'Surname field is empty');
    elsif p_given_name is null then
        raise_application_error(-20022, 'Given name field is empty');
    elsif p_address is null then
        raise_application_error(-20022, 'Address field is empty');
    elsif p_telephone is null or p_telephone < 1000000000 then
        raise_application_error(-20022, 'Telephone field is incorrect');
    end if;

    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        values (p_passport_id, 'organization', p_surname, p_given_name, p_passport_number, p_telephone, p_email, p_address, 'unlock', p_password);
        
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register organization', 'The organization "' || p_editor_id || '?' || p_passport_id || '?' || p_surname || '?' || p_given_name || '?' || p_passport_number || '?' || p_telephone || '?' || p_email  || '" already exists', sysdate);
        raise_application_error(-20006, 'The organization already exists');
    end;
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_editor then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'register organization', 'Invalid editor "' || p_editor_id || '?' || p_passport_id || '?' || p_surname || '?' || p_given_name || '?' || p_passport_number || '?' || p_telephone || '?' || p_email  || '"', sysdate);
        raise;
    end;
    when empty_field then
        raise;
    when others then
    begin
        log_internal_error('register organization', p_editor_id || '?' || p_passport_id || '?' || p_surname || '?' || p_given_name || '?' || p_passport_number || '?' || p_telephone || '?' || p_email || '?' || p_address);
    end;
end;

create or replace procedure add_auto_transfer(
    p_passport_id   in root_admin.users.passport_id%type,
    p_user_type     in root_admin.users.type%type,
    p_password      in root_admin.users.password%type,
    p_from_invoice  in root_admin.invoices.id%type,
    p_to_invoice    in root_admin.invoices.id%type,
    p_value         in root_admin.auto_transfers.value%type,
    p_percent       in root_admin.auto_transfers.percent%type,
    p_type          in root_admin.auto_transfers.type%type,
    p_duration      in root_admin.auto_transfers.duration%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add auto transfer', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_from_invoice || '?' || p_to_invoice || '?' || p_value || '?' || p_percent || '?' || p_type || '?' || p_duration || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_invoice_owner(p_passport_id, p_user_type, p_from_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add auto transfer', 'The specified invoice does not exist for the user "' || p_from_invoice || '?' || p_to_invoice || '?' || p_value || '"', sysdate);
        raise_application_error(-20025, 'Invalid invoice or owner invoice');
    end if;
    
    insert into auto_transfers(id, from_invoice, to_invoice, value, percent, type, open_date, duration, status)
        values (auto_transfers_ids.nextval, p_from_invoice, p_to_invoice, p_value, p_percent, p_type, sysdate, p_duration, 'active');
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when others then
    begin
        log_internal_error('add auto transfer', p_from_invoice || '?' || p_to_invoice || '?' || p_value || '?' || p_percent || '?' || p_type || '?' || p_duration);
    end;
end;

create or replace procedure add_currency(
    p_short_name  in root_admin.currency.short_name%type,
    p_name        in root_admin.currency.name%type
)
is begin
    insert into currency(short_name, name, value)
        values (p_short_name, p_name, 0);
    
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add currency', 'The currency already exists ' || p_short_name || '?' || p_name, sysdate);
        raise_application_error(-20006, 'The currency already exists');
    end;
    when others then
    begin
        log_internal_error('add currency', p_short_name || '?' || p_name);
    end;
end;

create or replace procedure add_invoice(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type,
    p_currency     in root_admin.currency.short_name%type,
    p_type         in root_admin.invoices.type%type,
    p_invoice_id   out root_admin.invoices.id%type,
    p_root         in root_admin.invoices.id%type := null
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add invoice', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_currency || '?' || p_type || '?' || p_root || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;
    
    p_invoice_id := invoice_ids.nextval;
    insert into invoices(id, user_id, user_type, value, currency, type, status, root)
        values (p_invoice_id, p_passport_id, p_user_type, 0, p_currency, p_type, 'unlock', p_root);
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add invoice', 'The invoice ' || p_invoice_id || ' already exists', sysdate);
        raise_application_error(-20006, 'The invoice already exists');
    end;
    when invalid_user then
        raise;
    when others then
    begin
        log_internal_error('add invoice', p_invoice_id || '?' || p_passport_id || '?' || p_user_type || '?' || p_currency || '?' || p_type || '?' || p_root);
    end;
end;

create or replace procedure create_card(
    p_passport_id  in root_admin.users.passport_id%type,
    p_invoice      in root_admin.invoices.id%type,
    p_pincode      in root_admin.cards.pincode%type
)
is
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
begin
    if is_invoice_owner(p_passport_id, 'base', p_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'create card', 'The user not belongs this invoice ' || p_passport_id || '?' || p_invoice || '?' || p_pincode, sysdate);
        raise_application_error(-20025, 'Invalid invoice or owner invoice');
    end if;
    
    insert into cards(id, invoice, pincode, status)
        values (cards_ids.nextval, p_invoice, p_pincode, 'unlock');
    
exception
    when dup_val_on_index then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'create card', 'The card already exists ' || p_passport_id || '?' || p_invoice || '?' || p_pincode, sysdate);
        raise_application_error(-20006, 'The card already exists');
    end;
    when invalid_invoice then
        raise;
    when others then
    begin
        log_internal_error('create card', p_passport_id || '?' || p_invoice || '?' || p_pincode);
    end;
end;

create or replace procedure set_status_transfer(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type,
    p_transfer_id  in root_admin.auto_transfers.id%type,
    p_status       in root_admin.auto_transfers.status%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_transfer exception;
    pragma exception_init(invalid_transfer, -20026);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status transfer', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_transfer_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;
    if is_auto_transfer_owner(p_passport_id, p_user_type, p_transfer_id) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status transfer', 'The specified auto transfer does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_transfer_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20026, 'Invalid auto transfer or owner auto transfer');
    end if;
    
    update auto_transfers set status = p_status where id = p_transfer_id;
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_user then
        raise;
    when invalid_transfer then
        raise;
    when others then
    begin
        log_internal_error('set status transfer', p_transfer_id || '?' || p_status);
    end;
end;

create or replace procedure set_status_invoice(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type,
    p_invoice_id   in root_admin.invoices.id%type,
    p_status       in root_admin.invoices.status%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status invoice', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_invoice_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_invoice_owner(p_passport_id, p_user_type, p_invoice_id) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'perform transfer', 'The specified invoice does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_invoice_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20025, 'Invalid invoice or owner invoice');
    end if;
    
    update invoices set status = p_status where id = p_invoice_id;
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when others then
    begin
        log_internal_error('set status invoice', p_invoice_id || '?' || p_status);
    end;
end;

create or replace procedure set_status_user(
    editor_passport_id  in root_admin.users.passport_id%type,
    editor_user_type    in root_admin.users.type%type,
    editor_password     in root_admin.users.password%type,
    target_passport_id  in root_admin.users.passport_id%type,
    target_user_type    in root_admin.users.type%type,
    p_status            in root_admin.users.status%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    no_privilegies exception;
    pragma exception_init(no_privilegies, -200024);
    invalid_user exception;
    pragma exception_init(invalid_user, -200023);
    not_exist exception;
    pragma exception_init(not_exist, -200005);
begin
    if editor_user_type != 'bank employee' then
        raise_application_error(-200024, 'Not privilegies');
    end if;
    
    if is_verified_user(editor_passport_id, editor_user_type, editor_password) = false then
        raise_application_error(-20023, 'Invalid admin user or password');
    end if;
    
    update users set status = p_status where passport_id = target_passport_id and type = target_user_type;
    if sql%rowcount = 0 then
        raise_application_error(-20005, 'Does not exist target user');
    end if;
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when no_privilegies then
        raise;
    when invalid_user then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status user', 'Invalide admin user or password "' || editor_passport_id || '?' || editor_user_type || '?' || target_passport_id || '?' || target_user_type || '?' || p_status || '"', sysdate);
        commit;
        raise;
    end;
    when not_exist then
        raise;
    when others then
    begin
        log_internal_error('set status user', editor_passport_id || '?' || editor_user_type || '?' || target_passport_id || '?' || target_user_type || '?' || p_status);
    end;
end;

create or replace procedure set_status_card(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type,
    p_card_id      in root_admin.cards.id%type,
    p_status       in root_admin.cards.status%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_card exception;
    pragma exception_init(invalid_card, -20028);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status card', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_card_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_card_owner(p_passport_id, p_card_id) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'set status card', 'The specified card does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_card_id || '?' || p_status || '"', sysdate);
        raise_application_error(-20028, 'Invalid card or card owner');
    end if;
    
    update cards set status = p_status where id = p_card_id;
    
exception
    when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_user then
        raise;
    when invalid_card then
        raise;
    when others then
    begin
        log_internal_error('set status card', p_passport_id || '?' || p_user_type || '?' || p_card_id || '?' || p_status);
    end;
end;

create or replace procedure set_currency(
    p_short_name  in root_admin.currency.short_name%type,
    p_new_value   in root_admin.currency.value%type
)
is begin
    update currency set value = p_new_value where short_name = p_short_name;
end;

create or replace procedure delete_user(
    p_passport_id in root_admin.users.passport_id%type,
    user_type   in root_admin.users.type%type,
    p_password    in root_admin.users.password%type
)
is
    invalide_user exception;
    pragma exception_init(invalide_user, -20023);
begin
    delete users u where passport_id = p_passport_id and type = user_type and password = p_password;
    if sql%rowcount = 0 then
        raise_application_error(-20023, 'Invalide user or password');
    end if;
    
exception
    when invalide_user then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'delete user', 'Invalide user or password "' || p_passport_id || '?' || user_type || '"', sysdate);
        raise;
    end;
    when others then
    begin
        log_internal_error('delete user', p_passport_id || '?' || user_type);
    end;
end;

create or replace procedure remove_invoice(
    p_passport_id  in root_admin.users.passport_id%type,
    p_user_type    in root_admin.users.type%type,
    p_password     in root_admin.users.password%type,
    p_invoice_id   in root_admin.invoices.id%type
)
is
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
    contain_child exception;
    pragma exception_init(contain_child, -20027);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'remove invoice', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_invoice_id || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if is_invoice_owner(p_passport_id, p_user_type, p_invoice_id) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'remove invoice', 'The specified invoice does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_invoice_id || '"', sysdate);
        raise_application_error(-20025, 'Invalid invoice or owner invoice');
    end if;

    if is_have_child(p_invoice_id) = true then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'remove invoice', 'The invoice contain child invoice. Deleting impossibly ' || p_passport_id || '?' || p_user_type || '?' || p_invoice_id, sysdate);
        raise_application_error(-20027, 'The invoice contain child invoice. Deleting impossibly');
    end if;
    
    delete from invoices where id = p_invoice_id and user_id = p_passport_id and user_type = p_user_type;
    
exception
    when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when contain_child then
        raise;
    when others then
    begin
        log_internal_error('remove invoice', p_passport_id || '?' || p_user_type || '?' || p_invoice_id);
    end;
end;

create or replace procedure drop_card(
    p_passport_id  in root_admin.users.passport_id%type,
    p_card_id      in root_admin.cards.id%type,
    p_pincode      in root_admin.cards.pincode%type
)
is
    invalid_card exception;
    pragma exception_init(invalid_card, -20028);
begin
    if is_card_owner(p_passport_id, p_card_id) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'drop card', 'Invalid card or pincode ' || p_passport_id || '?' || p_card_id, sysdate);
        raise_application_error(-20028, 'Invalid card or pincode');
    end if;
    
    delete cards where id = p_card_id;
    
exception
    when invalid_card then
        raise;
    when others then
    begin
        log_internal_error('drop card', p_card_id);
    end;
end;

create or replace procedure perform_transfer(
    p_passport_id         in root_admin.users.passport_id%type,
    p_user_type           in root_admin.users.type%type,
    p_password            in root_admin.users.password%type,
    p_from_invoice        in root_admin.invoices.id%type,
    p_to_invoice          in root_admin.invoices.id%type,
    p_transfer_value      in root_admin.invoices.value%type,
    p_transfer_currency   in root_admin.invoices.currency%type
)
is
    currency_value     root_admin.currency.value%type;
    transfer_size      root_admin.invoices.value%type := 0;
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    equal_zero exception;
    pragma exception_init(equal_zero, -20004);
    not_exist exception;
    pragma exception_init(not_exist, -20005);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    if p_transfer_value <= 0 then
        raise_application_error(-20004, 'The transfer amount cannot be less that or equal to zero');
    end if;
    
    if is_invoice_owner(p_passport_id, p_user_type, p_from_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'perform transfer', 'The specified invoice does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_from_invoice || '?' || p_to_invoice || '?' || p_transfer_value || '?' || p_transfer_currency || '"', sysdate);
        commit;
        raise_application_error(-20005, 'The specified invoice does not exist for the user');
    end if;
    
    transfer_size := 1;
    select value into currency_value from currency where short_name = p_transfer_currency;
    transfer_size := p_transfer_value / currency_value;
    
    if get_invoice_value(p_from_invoice) < transfer_size then
        raise_application_error(-20004, 'Insufficient funds in the invoice');
    end if;
    
    commit;
    update invoices set value = value - (transfer_size * get_currency_value(currency)) where id = p_from_invoice and status = 'unlock';
    update invoices set value = value + (transfer_size * get_currency_value(currency)) where id = p_to_invoice and status = 'unlock';
    if sql%rowcount = 0 then
        raise_application_error(-20005, 'The target invoice for the transfer was not found');
    end if;
    
exception
    when no_data_found then
    begin
        if transfer_size = 0 then
            raise_application_error(-20005, 'The specified invoice does not exist for the user');
        else
            raise_application_error(-20005, 'The specified currency does not exist');
        end if;
    end;
    when invalid_user then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'perform transfer', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_from_invoice || '?' || p_to_invoice || '?' || p_transfer_value || '?' || p_transfer_currency || '"', sysdate);
        commit;
        raise;
    end;
    when equal_zero then
        raise;
    when not_exist then
        raise;
    when others then
    begin
        rollback;
        log_internal_error('perform transfer', p_passport_id || '?' || p_user_type || '?' || p_from_invoice || '?' || p_to_invoice || '?' || p_transfer_value || '?' || p_transfer_currency);
    end;
end;

create or replace procedure rebind_invoice(
    p_passport_id      in root_admin.users.passport_id%type,
    p_user_type        in root_admin.users.type%type,
    p_password         in root_admin.users.password%type,
    p_new_passport_id  in root_admin.users.passport_id%type,
    p_target_invoice   in root_admin.invoices.id%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
    check_constraint exception;
    pragma exception_init(check_constraint, -2290);
    
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    invalid_invoice exception;
    pragma exception_init(invalid_invoice, -20025);
begin
    if is_verified_user(p_passport_id, p_user_type, p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'rebind invoice', 'Invalide user or password "' || p_passport_id || '?' || p_user_type || '?' || p_new_passport_id || '?' || p_target_invoice || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;
    
    if is_invoice_owner(p_passport_id, p_user_type, p_target_invoice) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'add auto transfer', 'The specified invoice does not exist for the user "' || p_passport_id || '?' || p_user_type || '?' || p_new_passport_id || '?' || p_target_invoice || '"', sysdate);
        raise_application_error(-20025, 'Invalid invoice or owner invoice');
    end if;
    
    update invoices set user_id = p_new_passport_id where id = p_target_invoice;
    
exception
when check_constraint then
    begin
        raise_application_error(-20003, 'Incorrectly entered data');
    end;
    when null_constraint then
    begin
        raise_application_error(-20002, 'Field(-s) has value null');
    end;
    when invalid_user then
        raise;
    when invalid_invoice then
        raise;
    when others then
    begin
        log_internal_error('rebind invoice', p_passport_id || '?' || p_user_type || '?' || p_new_passport_id || '?' || p_target_invoice);
    end;
end;

create or replace procedure cash_acceptance(
    p_terminal_id  in root_admin.users.passport_id%type,
    p_password     in root_admin.users.password%type,
    p_card_id      in root_admin.cards.id%type,
    p_pincode      in root_admin.cards.pincode%type,
    p_value        in root_admin.invoices.value%type
)
is
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);

    invoice_id number := 0;
begin
    if is_verified_user(p_terminal_id, 'terminal', p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'cash acceptance', 'Invalide user or password "' || p_terminal_id || '?' || p_card_id || '?' || p_value || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;
    
    select invoice into invoice_id from cards where id = p_card_id and pincode = p_pincode and status = 'unlock';
    update invoices set value = value + p_value where id = invoice_id;
    
exception
    when no_data_found then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'cash acceptance', 'Card invoice not exist ' || p_terminal_id || '?' || p_card_id || '?' || p_value, sysdate);
        raise_application_error(-20005, 'Card invoice not exist');
    end;
    when invalid_user then
        raise;
    when others then
    begin
        log_internal_error('cash acceptance', p_terminal_id || '?' || p_card_id || '?' || p_value);
    end;
end;

create or replace procedure cash_withdrawal(
    p_terminal_id  in root_admin.users.passport_id%type,
    p_password     in root_admin.users.password%type,
    p_card_id      in root_admin.cards.id%type,
    p_pincode      in root_admin.cards.pincode%type,
    p_value        in root_admin.invoices.value%type
)
is
    invalid_user exception;
    pragma exception_init(invalid_user, -20023);
    insuff_funds exception;
    pragma exception_init(insuff_funds, -20004);

    m_invoice_id root_admin.cards.invoice%type;
    m_currency root_admin.invoices.currency%type;
begin
    if is_verified_user(p_terminal_id, 'terminal', p_password) = false then
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'cash withdrawal', 'Invalide user or password "' || p_terminal_id || '?' || p_card_id || '?' || p_value || '"', sysdate);
        raise_application_error(-20023, 'Invalid user or password');
    end if;

    select invoice into m_invoice_id from cards where id = p_card_id and pincode = p_pincode and status = 'unlock';
    select currency into m_currency from invoices where id = m_invoice_id;
    if get_invoice_value(m_invoice_id) < p_value / get_currency_value(m_currency) then
        raise_application_error(-20004, 'Insufficient funds in the invoice');
    end if;
    
    update invoices set value = value - p_value where id = m_invoice_id;
    
exception
    when no_data_found then
    begin
        insert into changes_log(type, event_name, description, date_time)
            values ('error', 'cash withdrawal', 'Card invoice not exist ' || p_terminal_id || '?' || p_card_id || '?' || p_value, sysdate);
        raise_application_error(-20005, 'Card invoice not exist');
    end;
    when invalid_user then
        raise;
    when insuff_funds then
        raise;
    when others then
    begin
        log_internal_error('cash withdrawal', p_terminal_id || '?' || p_card_id || '?' || p_value);
    end;
end;

create or replace procedure accept_job(
    p_organization_id  in root_admin.users.passport_id%type,
    p_worker_id        in root_admin.users.passport_id%type,
    p_worker_invoice   in root_admin.invoices.id%type
)
is
    null_constraint exception;
    pragma exception_init(null_constraint, -1400);
begin
    apply_for_job(p_organization_id, p_worker_id, p_worker_invoice);
    
exception
    when null_constraint then
        raise;
    when no_data_found then
        raise;
    when others then
    begin
        log_internal_error('accept job', p_organization_id || '?' || p_worker_id || '?' || p_worker_invoice);
    end;
end;

create or replace procedure quit_job(
    p_organization_id  in root_admin.users.passport_id%type,
    p_worker_id        in root_admin.users.passport_id%type
)
as
    transfer_id number := 0;
begin
    select transfer_id into transfer_id from workers_register where organization_id = p_organization_id and worker_id = p_worker_id;
    
    commit;
    update auto_transfers set status = 'suspended' where transfer_id = transfer_id;
    update workers_register set status = 'quit', date_time = sysdate where status = 'accepted' and organization_id = p_organization_id and worker_id = p_worker_id;
    
exception
    when no_data_found then
    begin
        raise_application_error(-20002, 'The worker is not accepted to this organization');
    end;
    when others then
    begin
        log_internal_error('quit job', p_organization_id || '?' || p_worker_id);
    end;
end;

------------------------------------------
-- Export
------------------------------------------

create or replace procedure export_users(
    p_file_path varchar2,
    p_file_name varchar2 := 'users.xml'
)
is
    cb clob;
begin
    select xmlelement("USERS",
        xmlagg(xmlelement("USER",
            xmlforest(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
        ))
    ).getClobVal() into cb from users;
    
    dbms_xslprocessor.clob2file(cl => cb, flocation => p_file_path, fname => p_file_name);
end;

------------------------------------------
-- Import
------------------------------------------

create or replace function import_xml(
    p_file_path varchar2,
    p_file_name varchar2
) return clob
is
    dest int := 1;
    src int := 1;
    cs number := 0;
    lang int := 0;
    warn int := 0;
    bf bfile;
    c clob;
begin
    dbms_lob.createtemporary(c, true);
    
    bf := bfilename(p_file_path, p_file_name);
    dbms_lob.fileopen(bf, dbms_lob.file_readonly);
    dbms_lob.loadclobfromfile(
        dest_lob => c,
        src_bfile => bf,
        amount => dbms_lob.lobmaxsize,
        dest_offset => dest,
        src_offset => src,
        bfile_csid => cs,
        lang_context => lang,
        warning => warn
    );
    dbms_lob.fileclose(bf);
    
    return c;
end;

create or replace procedure import_users(
    p_file_path varchar2,
    p_file_name varchar2
)
is begin
    insert into users(passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password)
    select passport_id, type, surname, given_name, passport_number, telephone, email, address, status, password
    from xmltable(
        '/USERS/USER'
        passing xmltype(import_xml(p_file_path, p_file_name))
        columns
        passport_id     char(14),
        type            varchar2(14),
        surname         varchar2(32),
        given_name      varchar2(60),
        passport_number char(9),
        telephone       number(12),
        email           varchar2(40),
        address         varchar2(60),
        status          varchar2(6),
        password        varchar2(32)
    );
end;

------------------------------------------
-- Create views
------------------------------------------

create view exchange_rates
    as select * from currency_log;
    
create view transfers
    as select * from transfers_log;

create view changes
    as select * from changes_log;

create view internal_errors
    as select * from internal_errors_log;

------------------------------------------
-- Create roles
------------------------------------------

create role rl_bank_user;
grant create session                  to rl_bank_user;
grant execute on register_user        to rl_bank_user;
grant execute on register_accountant  to rl_bank_user;
grant execute on delete_user          to rl_bank_user;
grant execute on add_invoice          to rl_bank_user;
grant execute on remove_invoice       to rl_bank_user;
grant execute on perform_transfer     to rl_bank_user;
grant execute on add_auto_transfer    to rl_bank_user;
grant execute on set_status_card      to rl_bank_user;
grant execute on register_worker      to rl_bank_user;
grant execute on rebind_invoice       to rl_bank_user;
grant execute on accept_job           to rl_bank_user;
grant execute on quit_job             to rl_bank_user;
grant execute on get_currency_value   to rl_bank_user;
grant execute on get_user_jobs        to rl_bank_user;
grant execute on get_user_invoices    to rl_bank_user;
grant execute on get_user_messages    to rl_bank_user;
grant execute on get_user_cards       to rl_bank_user;
grant execute on get_personal_data    to rl_bank_user;
grant execute on get_workers          to rl_bank_user;
grant select  on exchange_rates       to rl_bank_user;
      
create role rl_bank_employee;
grant create session                    to rl_bank_employee;
grant execute on set_status_user        to rl_bank_employee;
grant execute on set_status_invoice     to rl_bank_employee;
grant execute on set_status_card        to rl_bank_employee;
grant execute on add_currency           to rl_bank_employee;
grant execute on create_card            to rl_bank_employee;
grant execute on drop_card              to rl_bank_employee;
grant execute on set_currency           to rl_bank_employee;
grant execute on register_bank_employee to rl_bank_employee;
grant execute on register_organization  to rl_bank_employee;
grant select  on exchange_rates         to rl_bank_employee;

create role rl_terminal;
grant create session             to rl_terminal;
grant execute on cash_acceptance to rl_terminal;
grant execute on cash_withdrawal to rl_terminal;

create role rl_local_admin;
grant create session               to rl_local_admin;
grant execute on register_terminal to rl_local_admin;
grant select  on transfers         to rl_local_admin;
grant select  on changes           to rl_local_admin;

grant rl_bank_user      to bank_user;
grant rl_bank_employee  to bank_employee;
grant rl_terminal       to terminal;
grant rl_local_admin    to local_admin;
commit;